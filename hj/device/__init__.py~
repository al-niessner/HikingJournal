'''Front end factory for reading a variety of devices
'''
import enum

class Interface(object):
    '''All GPS units are supported through this interface

    Use the constructor (__init__) to accept kwds from open() to build
    a specific instance of this interface for the rest of the hiking journal
    to use. The interface should make all devices look like a file system in
    the end. It should translate from whatever proprietary format the device
    actually uses to GPX for a uniform data model through the hiking journal.

    At the device level, the user should see the device as a list of files
    with routes, tracks, and waypoints separated into their own files.
    I chose this particular architecture/design because it mimics the half
    dozen or so GPS units that I have examined. After the device layer, the
    hiking journal is free to intermix the types.
    '''
    
    def _close(self):
        '''given the interface a change to close the device if needed'''
        return # does nothing by default so overriding is not required
    
    def _load(self):
        '''load the data from the device'''
        return # does nothing by default so overriding is not required

    def routes(self):
        '''a generator that yields one route filename at a time'''
        raise NotImplementedError()

    def tracks(self):
        '''a generator that yields one track filename at a time'''
        raise NotImplementedError()
    
    def waypoints(self):
        '''a generator that yields one waypoint filename at a time'''
        raise NotImplementedError()
    pass

class Type(enum.Enum):
    local_file = 0
    garmin_etrex_10 = 1
    pass

def close (d : Interface): d._close()
def open (t : Type, **kwds) -> Interface:
    g,l = {},{}
    exec ('import hj.device.' + t.name + '\n' +
          'I = hj.device.' + t.name + '.Interface', g, l)
    I = l['I']
    result = None
    
    if len (kwds) == 0: help (I)
    else:
        result = I(**kwds)
        result._load()
        pass
    return result
